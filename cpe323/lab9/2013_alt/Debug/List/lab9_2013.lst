###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         30/Oct/2014  15:46:21
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  D:\uah\cpe323\lab9\2013_alt\lab9_2013.c
#    Command line  =  
#        D:\uah\cpe323\lab9\2013_alt\lab9_2013.c -lCN
#        D:\uah\cpe323\lab9\2013_alt\Debug\List\ -o
#        D:\uah\cpe323\lab9\2013_alt\Debug\Obj\ --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --debug -D__MSP430F2013__ -e
#        --double=32 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\430\lib\dlib\dl430fn.h" -On --segment __data16=DATA16
#        --segment __data20=DATA20
#    List file     =  D:\uah\cpe323\lab9\2013_alt\Debug\List\lab9_2013.lst
#    Object file   =  D:\uah\cpe323\lab9\2013_alt\Debug\Obj\lab9_2013.r43
#
###############################################################################

D:\uah\cpe323\lab9\2013_alt\lab9_2013.c
      1          /***********************************************************************
      2           * Title: LAB 9 - MSP~2013
      3           * Date Due: 30-10-14
      4           * 
      5           * Description:
      6           * Listens on SPI and adjusts the rate of a blinking LED.
      7           *
      8           * By: Christopher 'ctag' Bero <csb0019@uah.edu>
      9           * Project: https://github.com/ctag/uah
     10           *
     11           * This software is licensed under the GPLv3,
     12           * consult the LICENSE file for more information.
     13           **********************************************************************/
     14          
     15          #include <msp430.h> // The *correct* include statement

   \                                 In  segment DATA16_AN, at 0x56
   \   unsigned char volatile DCOCTL
   \                     DCOCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x57
   \   unsigned char volatile BCSCTL1
   \                     BCSCTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x21
   \   unsigned char volatile P1OUT
   \                     P1OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x22
   \   unsigned char volatile P1DIR
   \                     P1DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x78
   \   union <unnamed> _A_USICTL0
   \                     _A_USICTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x7a
   \   union <unnamed> _A_USICKCTL
   \                     _A_USICKCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x7c
   \   union <unnamed> _A_USISRL
   \                     _A_USISRL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x10fe
   \   unsigned char const volatile CALDCO_1MHZ
   \                     CALDCO_1MHZ:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x10ff
   \   unsigned char const volatile CALBC1_1MHZ
   \                     CALBC1_1MHZ:
   \   000000                DS8 1
     16          
     17          #define LED_4X_STATE    0x34	// character '4' - 4X=4.0Hz
     18          #define LED_3X_STATE    0x33	// character '3' - 3X=2.0Hz
     19          #define LED_2X_STATE    0x32	// character '2' - 2X=1.0Hz
     20          #define LED_1X_STATE    0x31	// character '1' - 1X=0.5Hz
     21          #define LED_OFF_STATE   0x30    // character '0'
     22          #define LED_NUL_STATE   0x00    // character NULL - dummy write
     23          
     24          #define SET_LED()       P1OUT |= 0x01;
     25          #define RESET_LED()     P1OUT &= ~0x01;
     26          
     27          #define SET_BUSY_FLAG()   P1OUT |= 0x10;
     28          #define RESET_BUSY_FLAG() P1OUT &= ~0x10;
     29          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     30          unsigned char LEDState;
   \                     LEDState:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     31          unsigned char NextState;
   \                     NextState:
   \   000000                DS8 1
     32          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     33          long unsigned int delay_1x = 90000;
   \                     delay_1x:
   \   000000                DS8 4
   \   000004                REQUIRE `?<Initializer for delay_1x>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     34          long unsigned int delay_2x = 45000;
   \                     delay_2x:
   \   000000                DS8 4
   \   000004                REQUIRE `?<Initializer for delay_2x>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     35          long unsigned int delay_3x = 30000;
   \                     delay_3x:
   \   000000                DS8 4
   \   000004                REQUIRE `?<Initializer for delay_3x>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     36          long unsigned int delay_4x = 22500;
   \                     delay_4x:
   \   000000                DS8 4
   \   000004                REQUIRE `?<Initializer for delay_4x>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     37          long unsigned int delay = 90000;
   \                     delay:
   \   000000                DS8 4
   \   000004                REQUIRE `?<Initializer for delay>`
     38          

   \                                 In  segment CODE, align 2
     39          void SPISetup(void)
   \                     SPISetup:
     40          {
     41            
     42            USICTL0 |= USISWRST;      //Set UCSWRST -- needed for re-configuration process
   \   000000   D2D37800     BIS.B   #0x1, &0x78
     43            USICTL0 |= USIPE5 + USIPE6 + USIPE7 + USIOE; // SCLK-SDO-SDI port enable,MSB first   
   \   000004   F2D0E2007800 BIS.B   #0xe2, &0x78
     44            USICTL1 = USIIE;          // USI  Counter Interrupt enable                              
   \   00000A   F24010007900 MOV.B   #0x10, &0x79
     45            USICTL0 &= ~USISWRST;     // **Initialize USCI state machine**
   \   000010   D2C37800     BIC.B   #0x1, &0x78
     46          }
   \   000014   3041         RET
   \   000016                REQUIRE _A_USICTL0
     47          

   \                                 In  segment CODE, align 2
     48          void InitComm(void)
   \                     InitComm:
     49          { 
     50           USICNT = 8;                 // Load bit counter, clears IFG
   \   000000   F2427B00     MOV.B   #0x8, &0x7b
     51           USISRL = 0x00;          // set LED state
   \   000004   C2437C00     MOV.B   #0x0, &0x7c
     52           RESET_BUSY_FLAG();          // reset busy flag
   \   000008   F2C010002100 BIC.B   #0x10, &0x21
     53          }
   \   00000E   3041         RET
   \   000010                REQUIRE _A_USICKCTL
   \   000010                REQUIRE _A_USISRL
   \   000010                REQUIRE P1OUT
     54          

   \                                 In  segment CODE, align 2
     55          void main(void)
   \                     main:
     56          {
     57          	//WDTCTL = WDT_ADLY_250;	// 1 s interval timer
     58          	WDTCTL = (WDTPW|WDTHOLD);
   \   000000   B240805A2001 MOV.W   #0x5a80, &0x120
     59          	
     60          	 BCSCTL1 = CALBC1_1MHZ;                // Set DCO
   \   000006   D242FF105700 MOV.B   &0x10ff, &0x57
     61           DCOCTL = CALDCO_1MHZ;
   \   00000C   D242FE105600 MOV.B   &0x10fe, &0x56
     62          	
     63          	SPISetup();                       //USi module in SPI mode initialization
   \   000012   B012....     CALL    #SPISetup
     64          	InitComm();                       //Communication initialization 
   \   000016   B012....     CALL    #InitComm
     65          	
     66          	P1DIR |= BIT0; // LED3 as output
   \   00001A   D2D32200     BIS.B   #0x1, &0x22
     67          	P1OUT &= ~BIT0; // LED off
   \   00001E   D2C32100     BIC.B   #0x1, &0x21
     68          	//P1OUT |= BIT0;
     69          	
     70          	_EINT();			// Enable interrupts
   \   000022   32D2         EINT
     71          	// __enable_interrupt(); // Same as _EINT()?
     72          	
     73                  
     74          	while (1)
     75          	{
     76          		//_BIS_SR(LPM0_bits + GIE);           // Enter LPM0 w/ interrupt
     77                          
     78                    
     79          		switch (NextState)
   \                     ??main_1:
   \   000024   C293....     CMP.B   #0x0, &NextState
   \   000028   0324         JEQ     ??main_3
     80          		{
     81          		  case 0x00 :
     82          			break;
     83          		  default :
     84          			LEDState = NextState;          // new state
   \   00002A   D242........ MOV.B   &NextState, &LEDState
     85          			break;
     86          		}
     87          		 
     88          		if (LEDState == LED_1X_STATE)
   \                     ??main_3:
   \   000030   F2903100.... CMP.B   #0x31, &LEDState
   \   000036   0720         JNE     ??main_4
     89          		{
     90          		  delay = delay_1x;
   \   000038   9242........ MOV.W   &delay_1x, &delay
   \   00003E   9242........ MOV.W   &delay_1x + 2, &delay + 2
   \   000044   203C         JMP     ??main_5
     91          		}
     92          		else if (LEDState == LED_2X_STATE)
   \                     ??main_4:
   \   000046   F2903200.... CMP.B   #0x32, &LEDState
   \   00004C   0720         JNE     ??main_6
     93          		{
     94          		  delay = delay_2x;
   \   00004E   9242........ MOV.W   &delay_2x, &delay
   \   000054   9242........ MOV.W   &delay_2x + 2, &delay + 2
   \   00005A   153C         JMP     ??main_5
     95          		} else if (LEDState == LED_3X_STATE)
   \                     ??main_6:
   \   00005C   F2903300.... CMP.B   #0x33, &LEDState
   \   000062   0720         JNE     ??main_7
     96          		{
     97          		  delay = delay_3x;
   \   000064   9242........ MOV.W   &delay_3x, &delay
   \   00006A   9242........ MOV.W   &delay_3x + 2, &delay + 2
   \   000070   0A3C         JMP     ??main_5
     98          		} else if (LEDState == LED_4X_STATE)
   \                     ??main_7:
   \   000072   F2903400.... CMP.B   #0x34, &LEDState
   \   000078   0620         JNE     ??main_5
     99          		{
    100          		  delay = delay_4x;
   \   00007A   9242........ MOV.W   &delay_4x, &delay
   \   000080   9242........ MOV.W   &delay_4x + 2, &delay + 2
    101          		} else
    102          		{
    103          		}
    104          		
    105          		for (long unsigned int c = 0; c < delay; c++)
   \                     ??main_5:
   \   000086   0E43         MOV.W   #0x0, R14
   \   000088   0F43         MOV.W   #0x0, R15
   \                     ??main_0:
   \   00008A   1F92....     CMP.W   &delay + 2, R15
   \   00008E   0428         JNC     ??main_8
   \   000090   0720         JNE     ??main_9
   \   000092   1E92....     CMP.W   &delay, R14
   \   000096   042C         JC      ??main_9
    106          		{
    107          			asm("NOP");
   \                     ??main_8:
   \   000098   0343         NOP
    108                                  //P1OUT ^= BIT0;
    109          		}
   \   00009A   1E53         ADD.W   #0x1, R14
   \   00009C   0F63         ADDC.W  #0x0, R15
   \   00009E   F53F         JMP     ??main_0
    110          		
    111          		P1OUT ^= BIT0;
   \                     ??main_9:
   \   0000A0   D2E32100     XOR.B   #0x1, &0x21
    112          		
    113          		USISRL = 0x00;            // prepares new communication with new state
   \   0000A4   C2437C00     MOV.B   #0x0, &0x7c
    114              RESET_BUSY_FLAG();          // clears busy flag - ready for new communication
   \   0000A8   F2C010002100 BIC.B   #0x10, &0x21
   \   0000AE   BA3F         JMP     ??main_1
   \   0000B0                REQUIRE WDTCTL
   \   0000B0                REQUIRE BCSCTL1
   \   0000B0                REQUIRE CALBC1_1MHZ
   \   0000B0                REQUIRE DCOCTL
   \   0000B0                REQUIRE CALDCO_1MHZ
   \   0000B0                REQUIRE P1DIR
   \   0000B0                REQUIRE P1OUT
   \   0000B0                REQUIRE _A_USISRL
    115          	}
    116          }
    117          
    118          /*
    119           * USI ISR
    120           */
    121          #pragma vector = USI_VECTOR

   \                                 In  segment CODE, align 2
    122          __interrupt void USI_ISR(void)
   \                     USI_ISR:
    123          {
    124          SET_BUSY_FLAG();            // set busy flag - slave is ready with a new communication
   \   000000   F2D010002100 BIS.B   #0x10, &0x21
    125            NextState = USISRL;         // read new command
   \   000006   D2427C00.... MOV.B   &0x7c, &NextState
    126            USICNT = 8;                 // Load bit counter for next TX
   \   00000C   F2427B00     MOV.B   #0x8, &0x7b
    127            //_BIC_SR_IRQ(LPM4_bits);     // Exit from LPM4 on RETI
    128          }
   \   000010   0013         RETI
   \   000012                REQUIRE P1OUT
   \   000012                REQUIRE _A_USISRL
   \   000012                REQUIRE _A_USICKCTL

   \                                 In  segment INTVEC, offset 0x8, root
   \                     `??USI_ISR??INTVEC 8`:
   \   000008   ....         DC16    USI_ISR

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delay_1x>`:
   \   000000   905F0100     DC32 90000

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delay_2x>`:
   \   000000   C8AF0000     DC32 45000

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delay_3x>`:
   \   000000   30750000     DC32 30000

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delay_4x>`:
   \   000000   E4570000     DC32 22500

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for delay>`:
   \   000000   905F0100     DC32 90000
    129          
    130          
    131          
    132          
    133          
    134          
    135          
    136          
    137          
    138          
    139          
    140          
    141          
    142          
    143          
    144          
    145          
    146          
    147          
    148          
    149          
    150          
    151          
    152          
    153          
    154          
    155          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      2   InitComm
      2   SPISetup
      4   USI_ISR
      2   main
        2   -> InitComm
        2   -> SPISetup


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Initializer for delay>
       4  ?<Initializer for delay_1x>
       4  ?<Initializer for delay_2x>
       4  ?<Initializer for delay_3x>
       4  ?<Initializer for delay_4x>
       2  ??USI_ISR??INTVEC 8
       1  BCSCTL1
       1  CALBC1_1MHZ
       1  CALDCO_1MHZ
       1  DCOCTL
      16  InitComm
       1  LEDState
       1  NextState
       1  P1DIR
       1  P1OUT
      22  SPISetup
      18  USI_ISR
       2  WDTCTL
       2  _A_USICKCTL
       2  _A_USICTL0
       2  _A_USISRL
       4  delay
       4  delay_1x
       4  delay_2x
       4  delay_3x
       4  delay_4x
     176  main

 
 232 bytes in segment CODE
  14 bytes in segment DATA16_AN
  20 bytes in segment DATA16_I
  20 bytes in segment DATA16_ID
   2 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
 
 232 bytes of CODE  memory
  20 bytes of CONST memory (+  2 bytes shared)
  22 bytes of DATA  memory (+ 14 bytes shared)

Errors: none
Warnings: none
